#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/opening.h"
#include "images/arena.h"
#include "images/pikachu.h"
#include "images/gyarados.h"
#include "images/meowth.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  drawStart();

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    switch (state) {
      case START:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          drawPlay();
        }
        break;
      case PLAY:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          drawStart();
        } else if (collisionDetection() == 1 || score < 0) {
          state = LOSE;
          drawLose();
        } else if (checkWin() == 1) {
          state = WIN;
          drawWin();
        } else {
          moveEnemies();
          gameplayIter(&currentButtons, &previousButtons);
        }
        break;
      case WIN:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          drawStart();
        }
        break;
      case LOSE:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          drawStart();
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
/*
Draws the start screen and resets values.
*/
void drawStart(void) {
  score = 99;
  moves = 0;
  char op[] = "POKEMAZE";
  char start[] = "Press START";
  waitForVBlank();
  drawFullScreenImageDMA(opening);
  waitForVBlank();
  drawString(20, 98, op, BLUE);
  waitForVBlank();
  drawString(130, 87, start, MAGENTA);
}

/*
Draws the play screen and initializes player, enemies, and green gem.
*/
void drawPlay(void) {
  waitForVBlank();
  drawFullScreenImageDMA(arena);
  waitForVBlank();
  drawImageDMA(56, 0, PIKACHU_WIDTH, PIKACHU_HEIGHT, pikachu);
  drawImageDMA(0, 90, MEOWTH_WIDTH, MEOWTH_HEIGHT, meowth);
  drawImageDMA(130, 150, MEOWTH_WIDTH, MEOWTH_HEIGHT, meowth);
  drawImageDMA(56, 200, GYARADOS_WIDTH, GYARADOS_HEIGHT, gyarados);
  drawRectDMA(66, 228, 10, 10, GREEN);
  char scoreChar[] = "Your Score: ";
  char printScore[16];
  snprintf(printScore, 15, "%s%d\n", scoreChar, score);
  drawString(0, 0, printScore, BLUE);
  pikaPos.currX = 56;
  pikaPos.currY = 0;
  meowthPos1.currX = 0;
  meowthPos1.currY = 90;
  meowthPos1.disp = 1;
  meowthPos2.currX = 130;
  meowthPos2.currY = 150;
  meowthPos2.disp = 1;
  gyarPos.currX = 56;
  gyarPos.currY = 200;
  gyarPos.disp = 1;
  endPos.currX = 66;
  endPos.currY = 228;
}

/*
Draws the losing screen.
*/
void drawLose(void) {
  char op[] = "YOU LOSE";
  char start[] = "Press SELECT to Restart";
  waitForVBlank();
  drawFullScreenImageDMA(opening);
  waitForVBlank();
  drawString(20, 98, op, BLUE);
  waitForVBlank();
  drawString(130, 59, start, MAGENTA);
}

/*
Draws the winning screen with your score.
*/
void drawWin(void) {
  char op[] = "YOU WIN";
  char scoreChar[] = "Your Score: ";
  char printScore[16];
  int copyLength = 15;
  if (score < 10) {
    copyLength--;
  }
  snprintf(printScore, copyLength, "%s%d\n", scoreChar, score);
  char start[] = "Press SELECT to Restart";
  waitForVBlank();
  drawFullScreenImageDMA(opening);
  waitForVBlank();
  drawString(20, 98, op, BLUE);
  waitForVBlank();
  drawString(75, 79, printScore, MAGENTA);
  waitForVBlank();
  drawString(130, 59, start, GREEN);
}

/*
Loops through each cycle and runs a gameplay iteration cycle, moving the character and updating
score as needed.
*/
void gameplayIter(u32 *currButtons, u32 *prevButtons) {
  int colDisp = 1;
  int rowDisp = 1;
  int *row = &pikaPos.currX;
  int *col = &pikaPos.currY;
  if (KEY_JUST_PRESSED(BUTTON_RIGHT, *currButtons, *prevButtons)) {
    waitForVBlank();
    drawPartialImageDMA(*row, *col, PIKACHU_WIDTH, PIKACHU_HEIGHT, arena);
    *col = *col + colDisp; // shift column
    if (*col > WIDTH - PIKACHU_WIDTH) { // bounds checking for right
      *col = *col - colDisp;
    }
    drawImageDMA(*row, *col, PIKACHU_WIDTH, PIKACHU_HEIGHT, pikachu);
    moves++;
  } else if (KEY_JUST_PRESSED(BUTTON_LEFT, *currButtons, *prevButtons)) {
    waitForVBlank();
    drawPartialImageDMA(*row, *col, PIKACHU_WIDTH, PIKACHU_HEIGHT, arena);
    *col = *col - colDisp; // shift column
    if (*col < 0) { // bounds checking for left
      *col = 0;
    }
    drawImageDMA(*row, *col, PIKACHU_WIDTH, PIKACHU_HEIGHT, pikachu);
    moves++;
  } else if (KEY_JUST_PRESSED(BUTTON_DOWN, *currButtons, *prevButtons)) {
    waitForVBlank();
    drawPartialImageDMA(*row, *col, PIKACHU_WIDTH, PIKACHU_HEIGHT, arena);
    *row = *row + rowDisp; // shift row
    if (*row > HEIGHT - PIKACHU_HEIGHT) { // bounds checking for bottom
      *row = *row - rowDisp;
    }
    drawImageDMA(*row, *col, PIKACHU_WIDTH, PIKACHU_HEIGHT, pikachu);
    moves++;
  } else if (KEY_JUST_PRESSED(BUTTON_UP, *currButtons, *prevButtons)) {
    waitForVBlank();
    drawPartialImageDMA(*row, *col, PIKACHU_WIDTH, PIKACHU_HEIGHT, arena);
    *row = *row - rowDisp; // shift row
    if (*row < 0) { // bounds checking for top
      *row = 0;
    }
    drawImageDMA(*row, *col, PIKACHU_WIDTH, PIKACHU_HEIGHT, pikachu);
    moves++;
  }
  if (moves % 4 == 1) {
    waitForVBlank();
    drawPartialImageDMA(0, 0, 240, 8, arena);
    score = score - 1;
    char scoreChar[] = "Your Score: ";
    char printScore[16];
    int copyLength = 15;
    if (score < 10) {
      copyLength--;
    }
    snprintf(printScore, copyLength, "%s%d\n", scoreChar, score);
    drawString(0, 0, printScore, BLUE);
    moves++;
  }
  
}
/*
Function to collect and call all enemy motions.
*/
void moveEnemies(void) {
  moveMeowth1();
  moveMeowth2();
  moveGyarados();
}

/*
Moves first enemy.
*/
void moveMeowth1(void) { 
  int *row = &meowthPos1.currX;
  int *col = &meowthPos1.currY;
  int *rowDisp = &meowthPos1.disp;
  waitForVBlank();
  if (vBlankCounter % 2 == 0) {
    drawPartialImageDMA(*row, *col, MEOWTH_HEIGHT, MEOWTH_WIDTH, arena);
    *row = *row + *rowDisp; // shift row
    if (*row > HEIGHT - MEOWTH_HEIGHT) { // bounds checking for bottom
      *row = *row - *rowDisp;
      *rowDisp = -1;
    } else if (*row < 0) { // bounds checking for top
      *row = 0;
      *rowDisp = 1;
    }
    drawImageDMA(*row, *col, MEOWTH_HEIGHT, MEOWTH_WIDTH, meowth);
  }
}

/*
Moves second enemy.
*/
void moveMeowth2(void) { 
  int *row = &meowthPos2.currX;
  int *col = &meowthPos2.currY;
  int *rowDisp = &meowthPos2.disp;
  waitForVBlank();
  if (vBlankCounter % 2 == 0) {
    drawPartialImageDMA(*row, *col, MEOWTH_HEIGHT, MEOWTH_WIDTH, arena);
    *row = *row + *rowDisp; // shift row
    if (*row > HEIGHT - MEOWTH_HEIGHT) { // bounds checking for bottom
      *row = *row - *rowDisp;
      *rowDisp = -1;
    } else if (*row < 0) { // bounds checking for top
      *row = 0;
      *rowDisp = 1;
    }
    drawImageDMA(*row, *col, MEOWTH_HEIGHT, MEOWTH_WIDTH, meowth);
  }
}

/*
Moves third enemy.
*/
void moveGyarados(void) { 
  int *row = &gyarPos.currX;
  int *col = &gyarPos.currY;
  int *rowDisp = &gyarPos.disp;
  waitForVBlank();
  if (vBlankCounter % 2 == 0) {
    drawPartialImageDMA(*row, *col, GYARADOS_HEIGHT, GYARADOS_WIDTH, arena);
    *row = *row + *rowDisp; // shift row
    if (*row > HEIGHT - GYARADOS_HEIGHT) { // bounds checking for bottom
      *row = *row - *rowDisp;
      *rowDisp = -1;
    } else if (*row < 0) { // bounds checking for top
      *row = 0;
      *rowDisp = 1;
    }
    drawImageDMA(*row, *col, GYARADOS_HEIGHT, GYARADOS_WIDTH, gyarados);
  }
}

/*
Checks if player collides with any of the enemies, flags with a 1 if it does.
*/
int collisionDetection(void) {
  int myRow = pikaPos.currX;
  int myCol = pikaPos.currY;
  int enemyRow1 = meowthPos1.currX;
  int enemyCol1 = meowthPos1.currY;
  int enemyRow2 = meowthPos2.currX;
  int enemyCol2 = meowthPos2.currY;
  int enemyRow3 = gyarPos.currX;
  int enemyCol3 = gyarPos.currY;
  if (myRow + PIKACHU_WIDTH > enemyRow1 && myRow < enemyRow1 + MEOWTH_WIDTH) {
    if (myCol + PIKACHU_HEIGHT > enemyCol1 && myCol < enemyCol1 + MEOWTH_HEIGHT) {
      return 1;
    }
  } else if (myRow + PIKACHU_WIDTH > enemyRow2 && myRow < enemyRow2 + MEOWTH_WIDTH) {
    if (myCol + PIKACHU_HEIGHT > enemyCol2 && myCol < enemyCol2 + MEOWTH_HEIGHT) {
      return 1;
    }
  } else if (myRow + PIKACHU_WIDTH > enemyRow3 && myRow < enemyRow3 + GYARADOS_WIDTH) {
    if (myCol + PIKACHU_HEIGHT > enemyCol3 && myCol < enemyCol3 + GYARADOS_HEIGHT) {
      return 1;
    }
  }
  return 0;
}

/*
Checks if player collides with green gem, flags with a 1 if it does.
*/
int checkWin(void) {
  int myRow = pikaPos.currX;
  int myCol = pikaPos.currY;
  int enemyRow1 = endPos.currX;
  int enemyCol1 = endPos.currY;
  if (myRow + PIKACHU_WIDTH > enemyRow1 && myRow < enemyRow1 + 10) {
    if (myCol + PIKACHU_HEIGHT > enemyCol1 && myCol < enemyCol1 + 10) {
      return 1;
    }
  }
  return 0;
}

